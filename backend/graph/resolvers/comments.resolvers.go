package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"math"
	"musicboxd/database"
	"musicboxd/graph"
	"musicboxd/graph/model"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *mutationResolver) AddComment(ctx context.Context, reviewID string, text string, replyingToID *string) (*model.Comment, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedReviewID, err := primitive.ObjectIDFromHex(reviewID)
	if err != nil {
		return nil, err
	}

	comment := bson.M{
		"createdAt":  time.Now(),
		"likes":      []interface{}{},
		"dislikes":   []interface{}{},
		"repliesIds": []interface{}{},
		"reviewId":   convertedReviewID,
		"userId":     cc.UserID,
		"text":       text,
		"updatedAt":  time.Now(),
	}

	var convertedReplyingToID primitive.ObjectID
	if replyingToID != nil && *replyingToID != "" {
		convertedReplyingToID, err = primitive.ObjectIDFromHex(*replyingToID)
		if err != nil {
			return nil, err
		}

		comment["replyingToId"] = convertedReplyingToID
	}

	coll := database.GetDB().GetCollection("comments")
	result, err := coll.InsertOne(
		ctx,
		comment,
	)

	if err != nil {
		return nil, err
	}

	res := model.Comment{}
	err = coll.FindOne(ctx, bson.M{"_id": result.InsertedID}).Decode(&res)
	if err != nil {
		return nil, err
	}

	convertedCommentID, err := primitive.ObjectIDFromHex(*res.ID)
	if err != nil {
		return nil, err
	}

	coll = database.GetDB().GetCollection("reviews")
	review := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": convertedReviewID},
		bson.M{
			"$push": bson.M{
				"commentIds": convertedCommentID,
			},
		},
		options.FindOneAndUpdate().
			SetReturnDocument(options.After),
	)

	if review.Err() != nil {
		return nil, review.Err()
	}

	if replyingToID != nil && *replyingToID != "" {
		coll := database.GetDB().GetCollection("comments")
		result := coll.FindOneAndUpdate(
			ctx,
			bson.M{"_id": convertedReplyingToID},
			bson.M{
				"$push": bson.M{
					"repliesIds": convertedCommentID,
				},
			},
			options.FindOneAndUpdate().
				SetReturnDocument(options.After).
				SetProjection(bson.M{"_id": 1}),
		)
		if result.Err() != nil {
			return nil, result.Err()
		}
	}

	if isFieldRequested(ctx, "user") {
		convertedID, err := primitive.ObjectIDFromHex(*res.UserID)
		if err != nil {
			return nil, err
		}

		coll := database.GetDB().GetCollection("users")
		user := coll.FindOne(ctx, bson.M{"_id": convertedID})
		if user.Err() != nil {
			return nil, user.Err()
		}

		u := model.UserResponse{}
		err = user.Decode(&u)
		if err != nil {
			return nil, err
		}

		res.User = &u
	}

	return &res, nil
}

func (r *mutationResolver) AddLikeDislikeComment(ctx context.Context, commentID string, action string) (*model.Comment, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	comment, err := AddLikeDislike(ctx, cc.UserID, commentID, action, "comments")
	if err != nil {
		return nil, err
	}

	res := model.Comment{}
	err = comment.Decode(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (r *queryResolver) CommentsPage(ctx context.Context, reviewID string, pageSize *int, page int) (*model.CommentsPage, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedReviewID, err := primitive.ObjectIDFromHex(reviewID)
	if err != nil {
		return nil, err
	}

	filter := bson.M{
		"reviewId": convertedReviewID,
	}
	coll := database.GetDB().GetCollection("comments")
	res := model.CommentsPage{}

	currentPage := 1
	if page > 0 {
		currentPage = page
	}

	limit := 10
	if pageSize != nil && *pageSize > 0 {
		limit = min(*pageSize, 20)
	}

	skip := (currentPage - 1) * limit

	if isFieldRequested(ctx, "comments") {

		cursor, err := coll.Find(
			ctx,
			filter,
			options.Find().
				SetSort(bson.M{"createdAt": 1}).
				SetSkip(int64(skip)).
				SetLimit(int64(limit)).
				SetProjection(GetCommentProjection(cc.UserID)),
		)
		if err != nil {
			return nil, err
		}

		defer cursor.Close(ctx)
		var comments []*model.Comment
		if err = cursor.All(ctx, &comments); err != nil {
			return nil, err
		}

		if isFieldRequested(ctx, "comments.user") && len(comments) > 0 {
			// Unique user IDs
			userIDMap := make(map[string]bool)
			for _, comment := range comments {
				if comment.UserID != nil && *comment.UserID != "" {
					userIDMap[*comment.UserID] = true
				}
			}

			userIDs := make([]primitive.ObjectID, 0, len(userIDMap))
			for id := range userIDMap {
				objID, err := primitive.ObjectIDFromHex(id)
				if err != nil {
					return nil, err
				}
				userIDs = append(userIDs, objID)
			}

			usersColl := database.GetDB().GetCollection("users")
			usersCursor, err := usersColl.Find(
				ctx,
				bson.M{"_id": bson.M{"$in": userIDs}},
			)
			if err != nil {
				return nil, err
			}
			defer usersCursor.Close(ctx)

			var users []*model.UserResponse
			if err = usersCursor.All(ctx, &users); err != nil {
				return nil, err
			}

			userMap := make(map[string]*model.UserResponse)
			for _, user := range users {
				userMap[user.ID] = user
			}

			for _, comment := range comments {
				if user, ok := userMap[*comment.UserID]; ok {
					comment.User = user
				}
			}
		}

		res.Comments = comments
	}

	total, err := coll.CountDocuments(ctx, filter)
	if err != nil {
		return nil, err
	}

	res.TotalComments = int(total)
	res.TotalPages = int(math.Ceil(float64(total) / float64(limit)))
	res.HasNextPage = currentPage < res.TotalPages
	res.HasPreviousPage = currentPage > 1

	return &res, nil
}

func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
