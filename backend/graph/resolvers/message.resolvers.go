package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"math"
	"musicboxd/database"
	"musicboxd/graph"
	"musicboxd/graph/model"
	"time"

	"github.com/99designs/gqlgen/graphql/handler/transport"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, content string) (*model.Message, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	// TODO check if user is a participant in the chat

	document := bson.M{
		"_id":       primitive.NewObjectID(),
		"content":   content,
		"senderId":  cc.UserID,
		"createdAt": time.Now(),
	}

	convertedChatID, err := primitive.ObjectIDFromHex(chatID)
	if err != nil {
		return nil, fmt.Errorf("invalid chat ID: %w", err)
	}

	coll := database.GetDB().GetCollection("chats")
	chat, err := coll.UpdateOne(
		ctx,
		bson.M{"_id": convertedChatID},
		bson.M{
			"$push": bson.M{
				"messages": document,
			},
		},
		options.Update().SetUpsert(false),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to send message: %w", err)
	}

	if chat.MatchedCount == 0 {
		return nil, fmt.Errorf("chat not found")
	}

	res := &model.Message{
		ID:        document["_id"].(primitive.ObjectID).Hex(),
		Content:   document["content"].(string),
		SenderID:  document["senderId"].(primitive.ObjectID).Hex(),
		CreatedAt: document["createdAt"].(time.Time),
	}

	return res, nil
}

func (r *queryResolver) Chat(ctx context.Context, participantID string) (*model.Chat, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedParticipantID, err := primitive.ObjectIDFromHex(participantID)
	if err != nil {
		return nil, fmt.Errorf("invalid participant ID: %w", err)
	}

	coll := database.GetDB().GetCollection("chats")
	chat := coll.FindOne(
		ctx,
		bson.M{
			"participantId": convertedParticipantID,
		},
		options.FindOne().SetProjection(database.GetChatProjection(cc.UserID)),
	)

	if chat.Err() != nil {
		// If chat not found, create a new one, idc that this is a query resolver
		if chat.Err() == mongo.ErrNoDocuments {
			chat, err := CreateNewPrivateChat(ctx, nil, participantID)
			if err != nil {
				return nil, fmt.Errorf("failed to create chat: %w", err)
			}

			return chat, nil
		}
		return nil, fmt.Errorf("failed to retrieve chat: %w", chat.Err())
	}

	res := &model.Chat{}
	err = chat.Decode(res)
	if err != nil {
		return nil, fmt.Errorf("failed to decode chat: %w", err)
	}

	if isFieldRequested(ctx, "participant") {
		user, err := database.GetUserByPrimitiveID(ctx, convertedParticipantID)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve user: %w", err)
		}

		res.Participant = user
	}

	return res, nil
}

func (r *queryResolver) MessagesPage(ctx context.Context, chatID string, pageSize *int, page int) (*model.MessagesPage, error) {
	_, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedChatID, err := primitive.ObjectIDFromHex(chatID)
	if err != nil {
		return nil, fmt.Errorf("invalid chat ID: %w", err)
	}

	currentPage := 1
	if page > 0 {
		currentPage = page
	}

	limit := 10
	if pageSize != nil && *pageSize > 0 {
		limit = min(*pageSize, 50)
	}

	skip := (currentPage - 1) * limit

	coll := database.GetDB().GetCollection("chats")
	res := model.MessagesPage{}
	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "_id", Value: convertedChatID}}}},
		{{Key: "$project", Value: bson.D{
			{Key: "_id", Value: 1},
			{Key: "messagesCount", Value: bson.D{{Key: "$size", Value: "$messages"}}},
			{Key: "messages", Value: bson.D{
				{Key: "$slice", Value: bson.A{
					bson.D{{Key: "$reverseArray", Value: "$messages"}},
					skip,
					limit,
				}},
			}},
		}}},
	}

	cursor, err := coll.Aggregate(
		ctx,
		pipeline,
	)
	if err != nil {
		return nil, err
	}

	defer cursor.Close(ctx)
	var chat []*MessagesAggregationResult
	if err = cursor.All(ctx, &chat); err != nil {
		return nil, err
	}
	if len(chat) == 0 {
		return nil, fmt.Errorf("chat not found")
	}

	if isFieldRequested(ctx, "messages.sender") && len(chat[0].Messages) > 0 {
		// TODO add sender field to messages projection
		return nil, fmt.Errorf("sender field is not supported in messages projection")
	}

	res.Messages = chat[0].Messages
	res.TotalMessages = int(chat[0].MessagesCount)
	res.TotalPages = int(math.Ceil(float64(res.TotalMessages) / float64(limit)))
	res.HasNextPage = currentPage < res.TotalPages
	res.HasPreviousPage = currentPage > 1

	return &res, nil
}

func (r *subscriptionResolver) MessageAdded(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	connParams := transport.GetInitPayload(ctx)
	jwt := connParams["Authorization"].(string)

	_, err := ValidateJWTString(jwt)
	if err != nil {
		return nil, err
	}

	ch := make(chan *model.Message, 10)

	convertedChatID, err := primitive.ObjectIDFromHex(chatID)
	if err != nil {
		fmt.Printf("Invalid chat ID: %v\n", err)
		return nil, err
	}

	coll := database.GetDB().GetCollection("chats")
	pipeline := mongo.Pipeline{
		{{
			Key: "$match",
			Value: bson.M{
				"fullDocument._id": convertedChatID,
				"operationType":    "update",
			},
		}},
	}

	go func() {
		defer close(ch)

		changeStream, err := coll.Watch(ctx, pipeline, options.ChangeStream().SetFullDocument(options.UpdateLookup))
		if err != nil {
			fmt.Printf("Error creating change stream: %v\n", err)
			return
		}
		defer changeStream.Close(ctx)

		for changeStream.Next(ctx) {
			var changeEvent bson.M
			if err := changeStream.Decode(&changeEvent); err != nil {
				fmt.Printf("Error decoding change event: %v\n", err)
				continue
			}

			updateDescription := changeEvent["updateDescription"].(bson.M)
			updatedFields := updateDescription["updatedFields"].(bson.M)

			msg, err := MessageFromUpdatedFields(updatedFields)
			if err != nil {
				fmt.Printf("Error extracting message from updated fields: %v\n", err)
				continue
			}

			select {
			case ch <- msg:
			case <-ctx.Done():
				return
			}
		}
	}()

	return ch, nil
}

func (r *Resolver) Subscription() graph.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
