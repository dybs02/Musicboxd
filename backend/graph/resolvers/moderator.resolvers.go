package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"musicboxd/database"
	"musicboxd/graph/model"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// TODO if comment has already been reported, dont add it again
func (r *mutationResolver) ReportComment(ctx context.Context, id string) (string, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return "", err
	}

	commentID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	// TODO move to different dataset ?
	coll := database.GetDB().GetCollection("reported_comments")
	report, err := coll.InsertOne(
		ctx,
		bson.M{
			"commentId":  commentID,
			"reportedBy": cc.UserID,
			"createdAt":  primitive.NewDateTimeFromTime(time.Now()),
			"status":     "reported",
		},
	)

	if err != nil {
		return "", err
	}

	reportID, ok := report.InsertedID.(primitive.ObjectID)
	if !ok {
		return "", fmt.Errorf("failed to convert inserted ID to ObjectID")
	}

	return reportID.Hex(), nil
}

func (r *mutationResolver) ResolveComment(ctx context.Context, id string, status string, notes *string) (string, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return "", err
	}

	if cc.Role != "moderator" {
		return "", fmt.Errorf("unauthorized")
	}

	commentID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	if status != "deleted" && status != "ignored" {
		return "", fmt.Errorf("invalid status")
	}

	if notes == nil {
		defaultNotes := ""
		notes = &defaultNotes
	}

	coll := database.GetDB().GetCollection("reported_comments")
	comment := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": commentID},
		bson.M{
			// TODO only set is status is reported ??
			"$set": bson.M{
				"status":     status,
				"resolvedBy": cc.UserID,
				"notes":      notes,
				"resolvedAt": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	if comment.Err() != nil {
		return "", comment.Err()
	}

	if status == "ignored" {
		return commentID.Hex(), nil
	}

	reportedComment := model.ReportedComment{}
	err = comment.Decode(&reportedComment)
	if err != nil {
		return "", err
	}

	convertedCommentID, err := primitive.ObjectIDFromHex(reportedComment.CommentID)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	coll = database.GetDB().GetCollection("comments")
	deletedComment := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": convertedCommentID},
		bson.M{
			"$set": bson.M{
				"text":      "Comment deleted by moderator",
				"updatedAt": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		options.FindOneAndUpdate().
			SetReturnDocument(options.After),
	)

	if deletedComment.Err() != nil {
		return "", deletedComment.Err()
	}

	return commentID.Hex(), nil
}

func (r *queryResolver) ReportedComments(ctx context.Context, number *int) ([]*model.ReportedComment, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	if cc.Role != "moderator" {
		return nil, fmt.Errorf("unauthorized")
	}

	coll := database.GetDB().GetCollection("reported_comments")
	cursor, err := coll.Find(
		ctx,
		bson.M{
			"status": "reported", // add this as parameter
		},
		// TODO add pagination
		// options.Find().SetSort(bson.M{"createdAt": 1}).SetSkip(offset).SetLimit(int64(min(*number, 20))),
		options.Find().SetSort(bson.M{"createdAt": 1}).SetLimit(20),
	)
	if err != nil {
		return nil, err
	}

	defer cursor.Close(ctx)
	var res []*model.ReportedComment
	if err = cursor.All(ctx, &res); err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, fmt.Errorf("no reported comments found")
	}

	// TODO move those requests to a different function
	if isFieldRequested(ctx, "comment") {
		commentIDs := make([]primitive.ObjectID, 0, len(res))
		for _, reportedComment := range res {
			objID, err := primitive.ObjectIDFromHex(reportedComment.CommentID)
			if err != nil {
				return nil, err
			}
			commentIDs = append(commentIDs, objID)
		}

		coll = database.GetDB().GetCollection("comments")
		commentCursor, err := coll.Find(
			ctx,
			bson.M{"_id": bson.M{"$in": commentIDs}},
		)
		if err != nil {
			return nil, err
		}

		defer commentCursor.Close(ctx)

		var comments []*model.Comment
		if err = commentCursor.All(ctx, &comments); err != nil {
			return nil, err
		}

		commentMap := make(map[string]*model.Comment)
		for _, comment := range comments {
			commentMap[*comment.ID] = comment
		}

		if isFieldRequested(ctx, "comment.user") {
			userIDMap := make(map[string]bool)
			for _, comment := range comments {
				if comment.UserID != nil && *comment.UserID != "" {
					userIDMap[*comment.UserID] = true
				}
			}

			userIDs := make([]primitive.ObjectID, 0, len(userIDMap))
			for id := range userIDMap {
				objID, err := primitive.ObjectIDFromHex(id)
				if err != nil {
					return nil, err
				}
				userIDs = append(userIDs, objID)
			}

			usersColl := database.GetDB().GetCollection("users")
			usersCursor, err := usersColl.Find(
				ctx,
				bson.M{"_id": bson.M{"$in": userIDs}},
			)
			if err != nil {
				return nil, err
			}
			defer usersCursor.Close(ctx)

			var users []*model.UserResponse
			if err = usersCursor.All(ctx, &users); err != nil {
				return nil, err
			}

			userMap := make(map[string]*model.UserResponse)
			for _, user := range users {
				userMap[user.ID] = user
			}

			for _, comment := range comments {
				if comment.UserID != nil && *comment.UserID != "" {
					if user, ok := userMap[*comment.UserID]; ok {
						comment.User = user
					}
				}
			}
		}

		// Assign comments to reported comments
		for _, rc := range res {
			rc.Comment = commentMap[rc.CommentID]
		}
	}

	if isFieldRequested(ctx, "reportedByUser") {
		userIDMap := make(map[string]bool)
		for _, rc := range res {
			if rc.ReportedBy != "" {
				userIDMap[rc.ReportedBy] = true
			}
		}

		userIDs := make([]primitive.ObjectID, 0, len(userIDMap))
		for id := range userIDMap {
			objID, err := primitive.ObjectIDFromHex(id)
			if err != nil {
				return nil, err
			}
			userIDs = append(userIDs, objID)
		}

		usersColl := database.GetDB().GetCollection("users")
		usersCursor, err := usersColl.Find(
			ctx,
			bson.M{"_id": bson.M{"$in": userIDs}},
		)
		if err != nil {
			return nil, err
		}
		defer usersCursor.Close(ctx)

		var users []*model.UserResponse
		if err = usersCursor.All(ctx, &users); err != nil {
			return nil, err
		}

		userMap := make(map[string]*model.UserResponse)
		for _, user := range users {
			userMap[user.ID] = user
		}

		for _, rc := range res {
			if rc.ReportedBy != "" {
				if user, ok := userMap[rc.ReportedBy]; ok {
					rc.ReportedByUser = user
				}
			}
		}
	}

	return res, nil
}
