package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"musicboxd/database"
	"musicboxd/graph/model"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// TODO if comment has already been reported, dont add it again
func (r *mutationResolver) ReportComment(ctx context.Context, id string) (string, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return "", err
	}

	commentID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	// TODO move to different dataset ?
	coll := database.GetDB().GetCollection("reported_comments")
	report, err := coll.InsertOne(
		ctx,
		bson.M{
			"commentId":  commentID,
			"reportedBy": cc.UserID,
			"createdAt":  primitive.NewDateTimeFromTime(time.Now()),
			"status":     "reported",
		},
	)

	if err != nil {
		return "", err
	}

	reportID, ok := report.InsertedID.(primitive.ObjectID)
	if !ok {
		return "", fmt.Errorf("failed to convert inserted ID to ObjectID")
	}

	return reportID.Hex(), nil
}

func (r *mutationResolver) ResolveComment(ctx context.Context, id string, status string, notes *string) (string, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return "", err
	}

	if cc.Role != "moderator" {
		return "", fmt.Errorf("unauthorized")
	}

	commentID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	if status != "deleted" && status != "ignored" {
		return "", fmt.Errorf("invalid status")
	}

	if notes == nil {
		defaultNotes := ""
		notes = &defaultNotes
	}

	coll := database.GetDB().GetCollection("reported_comments")
	comment := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": commentID},
		bson.M{
			// TODO only set is status is reported ??
			"$set": bson.M{
				"status":     status,
				"resolvedBy": cc.UserID,
				"notes":      notes,
				"resolvedAt": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	if comment.Err() != nil {
		return "", comment.Err()
	}

	if status == "ignored" {
		return commentID.Hex(), nil
	}

	reportedComment := model.ReportedComment{}
	err = comment.Decode(&reportedComment)
	if err != nil {
		return "", err
	}

	convertedCommentID, err := primitive.ObjectIDFromHex(reportedComment.CommentID)
	if err != nil {
		return "", fmt.Errorf("invalid comment ID")
	}

	rewiews := database.GetDB().GetCollection("reviews")
	review := rewiews.FindOneAndUpdate(
		ctx,
		bson.M{
			"comments._id": bson.M{
				"$eq": convertedCommentID,
			},
		},
		bson.M{
			"$set": bson.M{
				"comments.$[elem].text":      "Comment deleted by moderator",
				"comments.$[elem].updatedAt": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		options.FindOneAndUpdate().
			SetReturnDocument(options.After).
			SetArrayFilters(options.ArrayFilters{
				Filters: []interface{}{
					bson.M{"elem._id": convertedCommentID},
				},
			}),
	)

	if review.Err() != nil {
		return "", review.Err()
	}

	return commentID.Hex(), nil
}

func (r *queryResolver) ReportedComments(ctx context.Context, number *int) ([]*model.ReportedComment, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	if cc.Role != "moderator" {
		return nil, fmt.Errorf("unauthorized")
	}

	coll := database.GetDB().GetCollection("reported_comments")
	cursor, err := coll.Find(
		ctx,
		bson.M{
			"status": "reported", // add this as parameter
		},
		// TODO add pagination
		// options.Find().SetSort(bson.M{"createdAt": 1}).SetSkip(offset).SetLimit(int64(min(*number, 20))),
		options.Find().SetSort(bson.M{"createdAt": 1}).SetLimit(20),
	)
	if err != nil {
		return nil, err
	}

	defer cursor.Close(ctx)

	res := []*model.ReportedComment{}
	for cursor.Next(ctx) {
		reportedComment := model.ReportedComment{}
		err = cursor.Decode(&reportedComment)
		if err != nil {
			return nil, err
		}
		res = append(res, &reportedComment)
	}

	err = cursor.Err()
	if err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, fmt.Errorf("no reported comments found")
	}

	for i, reportedComment := range res {

		// TODO move those requests to a different function
		if isFieldRequested(ctx, "comment") {
			review := model.Review{}

			convertedID, err := primitive.ObjectIDFromHex(reportedComment.CommentID)
			if err != nil {
				return nil, err
			}

			coll := database.GetDB().GetCollection("reviews")
			err = coll.FindOne(
				ctx,
				bson.M{
					"comments._id": bson.M{
						"$eq": convertedID,
					},
				},
			).Decode(&review)
			if err != nil {
				return nil, err
			}
			if len(review.Comments) == 0 {
				return nil, fmt.Errorf("no comments found")
			}

			for _, comment := range review.Comments {
				if *comment.ID == reportedComment.CommentID {
					res[i].Comment = comment
					break
				}
			}

			if isFieldRequested(ctx, "comment.user") {
				coll := database.GetDB().GetCollection("users")

				convertedID, err := primitive.ObjectIDFromHex(*res[i].Comment.UserID)
				if err != nil {
					return nil, err
				}

				user := coll.FindOne(ctx, bson.M{"_id": convertedID})
				if user.Err() != nil {
					return nil, user.Err()
				}

				u := model.UserResponse{}
				err = user.Decode(&u)
				if err != nil {
					return nil, err
				}

				res[i].Comment.User = &u
			}
		}

		if isFieldRequested(ctx, "reportedByUser") {
			coll := database.GetDB().GetCollection("users")

			convertedID, err := primitive.ObjectIDFromHex(res[i].ReportedBy)
			if err != nil {
				return nil, err
			}

			user := coll.FindOne(ctx, bson.M{"_id": convertedID})
			if user.Err() != nil {
				return nil, user.Err()
			}

			u := model.UserResponse{}
			err = user.Decode(&u)
			if err != nil {
				return nil, err
			}

			res[i].ReportedByUser = &u
		}
	}

	return res, nil
}
