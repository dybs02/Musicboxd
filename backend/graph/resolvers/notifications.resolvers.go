package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"math"
	"musicboxd/database"
	"musicboxd/graph/model"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *mutationResolver) MarkNotificationAsRead(ctx context.Context, notificationID string) (*model.Notification, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedNotificationID, err := primitive.ObjectIDFromHex(notificationID)
	if err != nil {
		return nil, fmt.Errorf("invalid notification ID: %w", err)
	}

	coll := database.GetDB().GetCollection("notifications")
	res := coll.FindOneAndUpdate(
		ctx,
		bson.M{
			"_id":            convertedNotificationID,
			"notifiedUserId": cc.UserID,
			"isRead":         false,
		},
		bson.M{
			"$set": bson.M{
				"isRead": true,
			},
		},
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)

	if res.Err() != nil {
		return nil, fmt.Errorf("failed to mark notification as read: %w", res.Err())
	}

	var notification model.Notification
	if err := res.Decode(&notification); err != nil {
		return nil, fmt.Errorf("failed to decode notification: %w", err)
	}

	return &notification, nil
}

func (r *mutationResolver) MarkAllNotificationsAsRead(ctx context.Context) (bool, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return false, err
	}

	coll := database.GetDB().GetCollection("notifications")
	_, err = coll.UpdateMany(
		ctx,
		bson.M{
			"notifiedUserId": cc.UserID,
			"isRead":         false,
		},
		bson.M{
			"$set": bson.M{
				"isRead": true,
			},
		},
		options.Update().SetUpsert(false),
	)
	if err != nil {
		return false, fmt.Errorf("failed to mark all notifications as read: %w", err)
	}

	return true, nil
}

func (r *queryResolver) NotificationsPage(ctx context.Context, pageSize *int, page int) (*model.NotificationsPage, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	currentPage := 1
	if page > 0 {
		currentPage = page
	}

	limit := 10
	if pageSize != nil && *pageSize > 0 {
		limit = min(*pageSize, 50)
	}

	skip := (currentPage - 1) * limit

	coll := database.GetDB().GetCollection("notifications")
	res := model.NotificationsPage{}
	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.D{{Key: "notifiedUserId", Value: cc.UserID}}}},
		{{Key: "$facet", Value: bson.D{
			{Key: "data", Value: bson.A{
				bson.D{{Key: "$sort", Value: bson.D{{Key: "createdAt", Value: -1}}}},
				bson.D{{Key: "$skip", Value: skip}},
				bson.D{{Key: "$limit", Value: limit}},
			}},
			{Key: "metadata", Value: bson.A{
				bson.D{{Key: "$count", Value: "totalNotifications"}},
			}},
		}}},
	}

	cursor, err := coll.Aggregate(
		ctx,
		pipeline,
	)
	if err != nil {
		return nil, err
	}

	defer cursor.Close(ctx)

	var result []*NotificationsAggregationResult
	if err = cursor.All(ctx, &result); err != nil {
		return nil, fmt.Errorf("failed to fetch notifications: %w", err)
	}

	if len(result[0].Data) == 0 {
		res.Notifications = []*model.Notification{}
		res.TotalNotifications = 0
		res.TotalPages = 0
		res.HasNextPage = false
		res.HasPreviousPage = false
		return &res, nil
	}

	totalNotifications := result[0].Metadata[0].TotalNotifications

	res.Notifications = result[0].Data
	res.TotalNotifications = totalNotifications
	res.TotalPages = int(math.Ceil(float64(totalNotifications) / float64(limit)))
	res.HasNextPage = currentPage < res.TotalPages
	res.HasPreviousPage = currentPage > 1

	return &res, nil
}
