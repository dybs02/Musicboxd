package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"math"
	"musicboxd/database"
	"musicboxd/graph/model"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *mutationResolver) CreatePost(ctx context.Context, content string, linkedReviewID *string) (*model.Post, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	document := bson.M{
		"content":   content,
		"userId":    cc.UserID,
		"createdAt": time.Now(),
		"updatedAt": time.Now(),
		"likes":     []interface{}{},
		"dislikes":  []interface{}{},
		"comments":  []interface{}{},
	}

	if linkedReviewID != nil {
		document["linkedReviewId"] = *linkedReviewID
	}

	coll := database.GetDB().GetCollection("posts")
	post, err := coll.InsertOne(
		ctx,
		document,
		options.InsertOne(),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create post: %w", err)
	}

	res := model.Post{}
	err = coll.FindOne(
		ctx,
		bson.M{"_id": post.InsertedID},
		options.FindOne().SetProjection(database.GetPostProjection(cc.UserID)),
	).Decode(&res)
	if err != nil {
		return nil, err
	}

	if isFieldRequested(ctx, "user") {
		u, err := database.GetUserByID(ctx, res.UserID)
		if err != nil {
			return nil, err
		}

		res.User = u
	}

	return &res, nil
}

func (r *mutationResolver) UpdatePost(ctx context.Context, id string, content string) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: UpdatePost - updatePost"))
}

func (r *mutationResolver) DeletePost(ctx context.Context, id string) (string, error) {
	panic(fmt.Errorf("not implemented: DeletePost - deletePost"))
}

func (r *mutationResolver) AddLikeDislikePost(ctx context.Context, postID string, action string) (*model.Post, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	post, err := AddLikeDislike(ctx, cc.UserID, postID, action, "posts")
	if err != nil {
		return nil, err
	}

	res := model.Post{}
	err = post.Decode(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (r *queryResolver) GetRecentPost(ctx context.Context, pageSize *int, page int, typeArg *string) (*model.RecentPosts, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	// Default to "all" type, which shows all posts
	filter := bson.M{}
	if *typeArg == "following" {
		following, err := database.GetFollowingIDs(ctx, cc.UserID)
		if err != nil {
			return nil, fmt.Errorf("failed to get following: %w", err)
		}

		filter["userId"] = bson.M{"$in": following}
	}
	if *typeArg == "user" {
		filter["userId"] = cc.UserID
	}

	coll := database.GetDB().GetCollection("posts")
	res := &model.RecentPosts{}

	currentPage := 1
	if page > 0 {
		currentPage = page
	}

	limit := 10
	if pageSize != nil && *pageSize > 0 {
		limit = min(*pageSize, 20)
	}

	skip := (currentPage - 1) * limit

	if isFieldRequested(ctx, "posts") {
		cursor, err := coll.Find(
			ctx,
			filter,
			options.Find().
				SetSort(bson.M{"createdAt": -1}).
				SetSkip(int64(skip)).
				SetLimit(int64(limit)).
				SetProjection(database.GetPostProjection(cc.UserID)),
		)
		if err != nil {
			return nil, err
		}

		defer cursor.Close(ctx)
		var posts []*model.Post
		if err = cursor.All(ctx, &posts); err != nil {
			return nil, err
		}

		if isFieldRequested(ctx, "posts.user") && len(posts) > 0 {
			userIDMap := make(map[string]bool)
			for _, post := range posts {
				if post.UserID != "" {
					userIDMap[post.UserID] = true
				}
			}

			userMap, err := database.GetUsers(ctx, userIDMap)
			if err != nil {
				return nil, fmt.Errorf("failed to get users: %w", err)
			}

			for _, post := range posts {
				if user, ok := userMap[post.UserID]; ok {
					post.User = user
				}
			}
		}

		if isFieldRequested(ctx, "posts.linkedReview") && len(posts) > 0 {
			reviewsIDMap := make(map[string]bool)
			for _, post := range posts {
				if post.LinkedReviewID != nil && *post.LinkedReviewID != "" {
					reviewsIDMap[*post.LinkedReviewID] = true
				}
			}

			reviewMap, err := database.GetReviews(ctx, reviewsIDMap, cc.UserID)
			if err != nil {
				return nil, fmt.Errorf("failed to get reviews: %w", err)
			}

			for _, post := range posts {
				if post.LinkedReviewID == nil || *post.LinkedReviewID == "" {
					continue
				}
				if review, ok := reviewMap[*post.LinkedReviewID]; ok {
					post.LinkedReview = review
				}
			}

			if isFieldRequested(ctx, "posts.linkedReview.user") {
				userIDMap := make(map[string]bool)
				for _, post := range posts {
					if post.LinkedReview != nil && post.LinkedReview.UserID != "" {
						if post.LinkedReview.UserID != "" {
							userIDMap[post.UserID] = true
						}
					}
				}

				userMap, err := database.GetUsers(ctx, userIDMap)
				if err != nil {
					return nil, fmt.Errorf("failed to get users: %w", err)
				}

				for _, post := range posts {
					if post.LinkedReview != nil && post.LinkedReview.UserID != "" {
						if user, ok := userMap[post.LinkedReview.UserID]; ok {
							post.LinkedReview.User = user
						}
					}
				}
			}
		}

		res.Posts = posts
	}

	total, err := coll.CountDocuments(ctx, filter)
	if err != nil {
		return nil, err
	}

	res.TotalPosts = int(total)
	res.TotalPages = int(math.Ceil(float64(total) / float64(limit)))
	res.HasNextPage = currentPage < res.TotalPages
	res.HasPreviousPage = currentPage > 1

	return res, nil
}
