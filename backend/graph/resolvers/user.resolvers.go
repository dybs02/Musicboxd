package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"errors"
	"fmt"
	"musicboxd/database"
	"musicboxd/graph/model"
	"musicboxd/hlp"
	"slices"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *mutationResolver) UpdateCurrentUser(ctx context.Context, displayName *string, favouriteAlbum *model.FavouriteAlbumEntryInput) (*model.UserResponse, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	changedValues := bson.M{}
	filters := bson.M{
		"_id": cc.UserID,
	}

	if displayName != nil {
		changedValues["displayName"] = *displayName
	}

	if favouriteAlbum != nil {
		if !slices.Contains([]int{1, 2, 3, 4}, favouriteAlbum.Key) {
			return nil, errors.New("invalid favourite album key")
		}

		accessToken, err := GetUserAccessToken(ctx)
		if err != nil {
			return nil, err
		}

		album, err := hlp.SpotifyGetAlbum(favouriteAlbum.AlbumID, accessToken)
		if err != nil {
			return nil, err
		}

		// TODO not sure if updating displayName at the same time will work
		changedValues["favouriteAlbums.$.album"] = bson.M{
			"albumId": album.ID,
			"name":    album.Name,
			"images":  album.Images,
			"artists": album.Artists,
		}

		filters["favouriteAlbums.key"] = favouriteAlbum.Key
	}

	if len(changedValues) == 0 {
		return nil, nil
	}

	coll := database.GetDB().GetCollection("users")
	user := coll.FindOneAndUpdate(
		ctx,
		filters,
		bson.M{"$set": changedValues},
		options.FindOneAndUpdate().SetReturnDocument(options.After),
	)
	if user.Err() != nil {
		return nil, user.Err()
	}

	res := model.UserResponse{}
	err = user.Decode(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (r *mutationResolver) FollowUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	followingID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	coll := database.GetDB().GetCollection("users")
	user := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": cc.UserID, "followingUsers": bson.M{"$ne": followingID}},
		bson.M{"$addToSet": bson.M{"followingUsers": followingID}},
		options.
			FindOneAndUpdate().
			SetReturnDocument(options.After).
			SetProjection(database.GetUserProjection(cc.UserID)),
	)
	if user.Err() != nil {
		return nil, user.Err()
	}

	res := model.UserResponse{}
	err = user.Decode(&res)
	if err != nil {
		return nil, err
	}

	// Update the follower list of the followed user

	return &res, nil
}

func (r *mutationResolver) UnfollowUser(ctx context.Context, userID string) (*model.UserResponse, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	followingID, err := primitive.ObjectIDFromHex(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	coll := database.GetDB().GetCollection("users")
	user := coll.FindOneAndUpdate(
		ctx,
		bson.M{"_id": cc.UserID, "followingUsers": bson.M{"$eq": followingID}},
		bson.M{"$pull": bson.M{"followingUsers": followingID}},
		options.
			FindOneAndUpdate().
			SetReturnDocument(options.After).
			SetProjection(database.GetUserProjection(cc.UserID)),
	)
	if user.Err() != nil {
		return nil, user.Err()
	}

	res := model.UserResponse{}
	err = user.Decode(&res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

func (r *queryResolver) UserByDisplayName(ctx context.Context, displayName string) (*model.UserResponse, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	coll := database.GetDB().GetCollection("users")
	user := coll.FindOne(
		ctx,
		bson.M{"displayName": displayName},
		options.FindOne().SetProjection(database.GetUserProjection(cc.UserID)),
	)
	if user.Err() != nil {
		return nil, user.Err()
	}

	res := model.UserResponse{}
	err = user.Decode(&res)
	if err != nil {
		return nil, err
	}
	return &res, nil
}

func (r *queryResolver) UserByID(ctx context.Context, id string) (*model.UserResponse, error) {
	cc, err := ValidateJWT(ctx)
	if err != nil {
		return nil, err
	}

	convertedID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}

	coll := database.GetDB().GetCollection("users")
	user := coll.FindOne(
		ctx,
		bson.M{"_id": convertedID},
		options.FindOne().SetProjection(database.GetUserProjection(cc.UserID)),
	)
	if user.Err() != nil {
		return nil, user.Err()
	}

	res := model.UserResponse{}
	err = user.Decode(&res)
	if err != nil {
		return nil, err
	}

	if isFieldRequested(ctx, "albumReviewsNumber") || isFieldRequested(ctx, "trackReviewsNumber") {
		convertedID, err := primitive.ObjectIDFromHex(res.ID)
		if err != nil {
			return nil, err
		}

		counts, err := GetUserReviewNumbers(ctx, convertedID)
		if err != nil {
			return nil, err
		}

		albumReviews := int(counts.AlbumReviews)
		trackReviews := int(counts.TrackReviews)
		res.AlbumReviewsNumber = &albumReviews
		res.TrackReviewsNumber = &trackReviews
	}

	return &res, nil
}
